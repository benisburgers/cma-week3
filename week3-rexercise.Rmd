---
title: "Week 3 Exercises"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

# Tasks and Inputs

## Task 1: Segmentation

### Install libraries

```{r warning = FALSE, message = FALSE}
library(tidyverse)
```

### Import Data

```{r}
caro <- read_delim('caro60.csv')
caro
```

### Custom-Segment the Data

```{r}
caro <- caro %>%
  mutate(
    nMinus3 = sqrt((lag(E,3)-E)^2+(lag(N,3)-N)^2),   # distance to pos -3 minutes
    nMinus2 = sqrt((lag(E,2)-E)^2+(lag(N,2)-N)^2),   # distance to pos -2 minutes
    nMinus1 = sqrt((lag(E,1)-E)^2+(lag(N,1)-N)^2),   # distance to pos -1 minutes
    nPlus1  = sqrt((E-lead(E,1))^2+(N-lead(N,1))^2), # distance to pos +1 mintues
    nPlus2  = sqrt((E-lead(E,2))^2+(N-lead(N,2))^2), # distance to pos +2 minutes
    nPlus3  = sqrt((E-lead(E,3))^2+(N-lead(N,3))^2)  # distance to pos +3 minutes
  )
caro
```

## Task 2: Specify and apply threshold *d*

### Exploring the distances between positions

```{r, warning=FALSE}
caro %>%
ggplot() +
  geom_histogram(mapping = aes(x = nMinus3))

caro %>%
ggplot() +
  geom_histogram(mapping = aes(x = nMinus2))
```

### Calculating the mean distance for every row

```{r}
caro <- caro %>%
  rowwise() %>%
  mutate(
    stepMean = mean(c(nMinus3, nMinus2, nMinus1, nPlus1, nPlus2, nPlus3))
  ) %>%
  ungroup()

caro
```

### Exploring the mean distances between positions

```{r}
caro %>%
  ggplot() +
  geom_histogram(mapping = aes(x = stepMean))

caro %>%
  ggplot() +
  geom_histogram(mapping = aes(x = stepMean)) +
  xlim(0, 10)
```
### Removing 'static' points

```{r}
# Static = Check whether the row step mean is lower than the overall steapMean average
caro <- caro %>%
    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))
caro

# Moving = Only the points where the row average is larger than the overall average
caro_moving <- caro %>%
  filter(static == FALSE)
caro_moving
```
## Task 3: Visualize segmented trajectories

```{r}
caro %>%
  ggplot(mapping = aes(x = E, y = N)) +
  geom_path() +
  geom_point(mapping = aes(color = static)) +
  coord_equal()
```
## Task 4: Segment-based analysis
```{r, warning=FALSE}
# No idea how this works:
rle_id <- function(vec){
  x <- rle(vec)$lengths
  as.factor(rep(seq_along(x), times=x))
}

caro <- caro %>%
  mutate(segment_id = rle_id(static))
caro

# IMO: A segment is done when the next begins, as such get access to the next data points time.
caro <- caro %>%
  mutate(nextDatetimeUTC = lead(DatetimeUTC, 1))

# Calculate segment duration by using the start_time of each segment and getting the next segment's start time
# I.e. one segment ends when the next one begins
segment_duration <- caro %>%
  group_by(segment_id) %>%
  summarise(start = min(DatetimeUTC),
            end = max(nextDatetimeUTC)) %>%
  mutate(duration_m = as.numeric(difftime(end, start)))
segment_duration

# Add segment_duration to caro
caro <- caro %>%
  left_join(segment_duration, by = "segment_id")

# Create a convenience variable whether a segment is longer or equal to 5 minutes
caro <- caro %>%
  mutate(segment_duration_5 = ifelse(duration_m >= 5, TRUE, FALSE))
caro

# Plot all segments that are not static
plot_all <- caro %>%
filter(static == FALSE) %>%
ggplot(mapping = aes(x = E, y = N, color = segment_id)) +
geom_path() +
geom_point() +
theme(legend.position = "bottom")
plot_all

# Plot all segments that are not static AND that are longer or equal to 5 minutes
plot_longer_than_5_minutes <- caro %>%
filter(static == FALSE) %>%
filter(segment_duration_5 == TRUE) %>%
ggplot(mapping = aes(x = E, y = N, color = segment_id)) +
geom_path() +
geom_point() +
theme(legend.position = "bottom")
plot_longer_than_5_minutes

# Combine these plots
plot_grid(plot_all, plot_longer_than_5_minutes)

```
Hey there! I'm not sure that I agree with your example in the exercise. For examle, segment 16 starts at 2015-09-15 11:19:00 and ends at 2015-09-15 11:25:00 when segment 17 begins. In my opinion that makes more sense, because a segment that has only 1 step (e.g. Segment 1) still has to be at least 1 minute long. And even if you don't agree with me, then segmend 16 would end at 2015-09-15 11:24:00, still making it 5 minutes long. Thereby we would have to show it. But maybe my calculations are also wrong somewhere.